

Test Driven Development is rooted in a test first approach to  developing software. This is concretely defined in the first of the [three simple laws of TDD](http://programmer.97things.oreilly.com/wiki/index.php/The_Three_Laws_of_Test-Driven_Development):

> 1. You are not allowed to write any production code unless it is to make a failing unit test pass

This is a pretty counter intuitive concept, it flips the traditional development process on its head. To those that aren't already believers in the benefits of TDD, you can expect some immediate and serious [side eye]() at the very thought of this.  

### But there's nothing to actually test, it won't even compile... My IDE will be lit up like a Christmas Tree

Funny enough, this is exactly the point. 

Getting started is hard, even when there are good requirements. The requirements generally only include the what the software should do, the how software goes about satisfying the requirements, its implementation is largely at discretion of the developer writing the code.

What happens next is that someone sits down to solve a high level problem with a high level understanding of what they want to do. It's only natural for a person to focus on the destination rather than the road to get there. The resulting solution has a tendency to then be a byproduct of organic growth rather than explicit design, functional but not necessarily testable.    

## Software's a Journey not a Destination 

Everyone's got deadlines, the immediate need is functioning code in a timely manner but, building software is almost never a one way trip. The fastest code to write isn't neccessarily mean the code is the fastest to maintain, and [teams in general spend more time in existing code than writing new code.]((https://blog.codinghorror.com/when-understanding-means-rewriting/)) 
 
The requirement to create a failing test first forces the developer to consider how the end result of her code will be utilized. This shifts the immediate focus away from completing the feature as a whole. The developer then becomes both the first consumer and reviewer of their code, work transitions away from organic growth to explicit intent.

## Organic Testing



## Test Driven Testing 
> 1. No testing unless you have identified and defined objective





