## DevOps is Different

## Ownership
As development has shifted from waterfall to agile and now dev ops, at each stage you see developers taking on more responsibility and accountability. 

Waterfall was isolationist, developers owned the act of coding, and in the stereotypical developer way had little to no interest what happened before or after they coded. Other roles on the teams in many ways acted as insulators to keep external forces away from developers. 

Agile was developers pulling the insulation away and shifting themselves left and taking more ownership of the product creation process. Developers required a real time feedback loop to build the right things and successfully react to change. 

Dev Ops is essentially the same process on the right side of the spectrum. Development takes more ownership of deployment, monitoring and application support. It's just too slow and cumbersome to react to the requirements of maintaining applications by filtering feedback through separate teams at scale.  

The benefits of integration outweigh the cost of the additional responsibility. 

## Code Continuous
To cope with the additional responsibilities, developers turned to their trusty friend *code*. 

With agile we see rise of tooling developed for *Continuous Integration* to alleviate the pain and reduce the risk in iterative development. 

In DevOps we see the rise of code and tools supporting *Continuous Deployment*. Even when many teams already had product installers, or automated deployment what was missing was the integration of that information.  

If developers are owning more of the product, as well as the release and deployments then testing naturally gets swept up in the process. In fact we see this pattern emerging with the concept of *Continuous Testing*. Code is being written, tools created to help solve the issue of integrated test execution and reporting into teams release pipeline. 

## People in the Pipeline

The purpose of creating the code and tooling to develop a pipeline isn't for there to be some manual intervention required part of the way through it. Putting exploratory testing somewhere in the later stages for the pipeline is akin to pointing a fire hose at someone and asking them to direct the flow to the next stage. 

When tester is in the pipeline, the can't win 
keeping up means compromising, slowing own is like parking on the freeway

Code based solutions enable rapid repeatable and practically real time feeds of in



## Intuition trap
testers love the certainty that deep testing provides, testing at the level of users feels very right, but testers have to reconcile themselves to identifying what tests they want to run, before pipeline, in pipeline and post pipeline. This requires deeper inspection on the motivation driving each test and its location in the pipeline.



## Replace Isolation with Collaboration
[clean up] It might seem like there is no where left for testers, development is eating up everything. Things are changing, what used to be a contentious us vs. them relationship is typically much more open.  The additional ownership has changed relationship dynamics. Success at scale requires collaboration. What this means is development is much more open to testing than in days of old. 

This cuts both ways though. It can be uncomfortable or difficult to open up and share what goes through your *testing mindset*

## Replace Execution with Communication

